#!/usr/bin/tclsh

proc test {name scripts exp result} {
    puts -nonewline $name
    set out [eval [concat [list exec java -cp obj geomlab.RunScript] $scripts \
		       [list -e $exp]]]
    regexp -line {^--> (.*)$} $out _ val
    if {[string equal $val $result]} {
	puts " OK"
    } else {
	puts " ***FAILED***"
    }
}

proc pngtest {name scripts exp result} {
    puts -nonewline $name
    set out [eval [concat [list exec java -cp obj geomlab.RunScript] $scripts \
		       [list -e {define savepic = _primitive("savepic")} \
			    -e "savepic($exp, \"foo.png\", 144, 0.5, 0.95)"]]]
    set hash [lindex [exec md5sum foo.png] 0]
    file delete foo.png
    if {[string equal $hash $result]} {
	puts " OK"
    } else {
	puts " ***FAILED*** $hash"
    }
}

test flic {test/script1.txt} {flic(3, 2)} \
    {[[[5, 6], [6, 7]], [[6, 7], [7, 8]]]}
test two3 {test/script1.txt} \
    {[two3(1, [2,1,3]), two3(1, [2,1]), two3(2, [2,1,3])]} \
    {[true, false, false]}
# test corout {src/testing.txt src/corout.txt} {main()} {163}
test valscope {} {let x = 3 in let x = x+1 in x} {4}
test valscope2 {} \
    {let f = lambda (x) x+1 in let f = lambda (x) f(2*x) in f(5)} {11}
test nestfree {} \
    {let x = 3 in let f = lambda (y) lambda (z) [x, y, z] in
	let g = f(4) in g(5)} {[3, 4, 5]}
test nestrec {} \
    {let f(x) = 
	let g(x) = if x = 0 then 1 else f(x-1)+1 in
	if x = 0 then 1 else 2*g(x-1) in f(8)} {46}
test letend {} {let x = 4 in (let x = 3 in x+x) + x} {10}
test letlet {} {(let x = 4 in x*x) + (let x = 5 in x*x)} {41}

pngtest man {} {man} fd6244145cb5b78afde0faaa79bd9e7c
pngtest couple {} {man $ woman} 407bdd041633b01f34c898e2c1ec1913
pngtest mike {src/testing.txt} {mike} 7dc398eb45ff89a68c76739ba50dc3ee
pngtest bush {src/testing.txt} {bush(system(3))} \
    9fd0de05e3e62e75ab5b824e52c6e68c
pngtest flip {} {flip(man)} 2cdd4418991f55c55f52da2fd48ce45b
pngtest rot {} {rot(man)} d28f2b28f46b8521a88120d4225ff8bf
pngtest stretch {} {stretch(1.5, man)} 20e7a391b24a7341082c970592616fee

test fac {test/script1.txt} {fac(6)} {720}
test patsyn {test/script1.txt} {oppx(left(30))} {right(30)}
test explode {} {explode("mike")} {["m", "i", "k", "e"]}
test explode2 {} {explode("")} {[]}
test implode {} {implode(["m", "i", "k", "e"])} {"mike"}
test implode2 {} {implode([])} {""}
test aspect {} {aspect(man)} {0.54545456}
test aspect2 {} {aspect(man $ man)} {1.0909091}
test aspect3 {} {aspect(rot(man))} {1.8333333}
test pixel {src/testing.txt} {pixel(mike, 20, 20)} \
    {rgb(0.039215686, 0.047058824, 0.094117647)}
test width {src/testing.txt} {[width(mike), height(mike)]} {[300, 400]}
test trig {} {[sin(45), cos(45), tan(45)]} {[0.70710678, 0.70710678, 1.0]}
# test fibcps {test/script1.txt} {fibcps(20, lambda (x) x)} {6765}
test mob {test/script1.txt} {mob(10)} {-67}

test trunk1 {test/script1.txt} {trunk(2.5)} {2}
test trunk2 {test/script1.txt} {trunk(3)} {3}

test or {} {[false or false, false or true, true or 1/0 > 0]} \
    {[false, true, true]}
test and {} {[true and true, true and false, false and 1/0 > 0]} \
    {[true, false, false]}
test not {} {[not (1 > 0), not (1 < 0)]} {[false, true]}
test booleq {} {[false = true, true = true]} {[false, true]}
# test boolord {} {[false < true, false > true]} {[true, false]}
# '<' expects a numeric argument
test cmdeq {} {[left(10)=left(10), left(10)=right(10), left(10)=left(20)]} \
    {[true, false, false]}
test sqrt {} {sqrt(2)} 1.4142136
test int {} {[int(-1.5), int(3), int(4.01)]} {[-2, 3, 4]}

test hard {test/hard.txt} {g(6)} {42}
file delete hard.gls
